#!/bin/bash

# eval_test.sh: Evaluate LinearB AI code review output for a given branch or PR URL
# Usage: ./eval_test.sh <branch-name|pr-url>

set -e

# !!!
# CHANGE THESE TO YOUR OWN VALUES
# !!!
default_owner="linearzig"
default_repo="eval-ai-code-review"

# !!!
# Set GITHUB_TOKEN in your shell
# !!!

GITHUB_API="https://api.github.com"
POLL_INTERVAL=30  # seconds
TIMEOUT=900       # 15 minutes
RESULTS_DIR="results"

# Helpers
print_status() { echo -e "[INFO] $1"; }
print_error() { echo -e "[ERROR] $1"; }
print_success() { echo -e "[SUCCESS] $1"; }

# Check args
if [ $# -lt 1 ]; then
  echo "Usage: $0 <branch-name|pr-url> [project_name] [scenario_name]"
  exit 1
fi
INPUT="$1"
USER_PROJECT_NAME="${2:-}"
USER_SCENARIO_NAME="${3:-}"

if [ -z "$GITHUB_TOKEN" ]; then
  print_error "GITHUB_TOKEN environment variable not set."
  exit 1
fi

# Set RESULTS_DIR to the directory of this script
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
RESULTS_DIR="$SCRIPT_DIR/results"
mkdir -p "$RESULTS_DIR"

IS_PR_URL=false
PR_URL=""
PROJECT_NAME="unknown"
SCENARIO_NAME="unknown"
# Determine if input is a PR URL or branch name
if [[ "$INPUT" =~ ^https://github.com/([^/]+)/([^/]+)/pull/([0-9]+) ]]; then
  REPO_OWNER="${BASH_REMATCH[1]}"
  REPO_NAME="${BASH_REMATCH[2]}"
  PR_NUMBER="${BASH_REMATCH[3]}"
  IS_PR_URL=true
  PR_URL="$INPUT"
  # Fetch the actual source branch name (head.ref) from the GitHub API
  PR_API_JSON=$(curl -s -H "Authorization: token $GITHUB_TOKEN" "$GITHUB_API/repos/$REPO_OWNER/$REPO_NAME/pulls/$PR_NUMBER")
  BRANCH_NAME=$(echo "$PR_API_JSON" | jq -r '.head.ref')
  print_status "Detected PR URL: owner=$REPO_OWNER, repo=$REPO_NAME, pr=$PR_NUMBER, branch=$BRANCH_NAME"
else
  REPO_OWNER="$default_owner"
  REPO_NAME="$default_repo"
  BRANCH_NAME="$INPUT"
  # 1. Find the PR for the branch
  print_status "Looking up PR for branch: $BRANCH_NAME"
  PR_JSON=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
    "$GITHUB_API/repos/$REPO_OWNER/$REPO_NAME/pulls?head=$REPO_OWNER:$BRANCH_NAME&state=open")
  PR_NUMBER=$(echo "$PR_JSON" | grep '"number":' | head -1 | sed 's/[^0-9]*//g')
  if [ -z "$PR_NUMBER" ]; then
    print_error "No open PR found for branch $BRANCH_NAME. Please create a PR and try again."
    exit 1
  fi
  print_status "Found PR #$PR_NUMBER for branch $BRANCH_NAME."
  PR_URL="https://github.com/$REPO_OWNER/$REPO_NAME/pull/$PR_NUMBER"
fi
# Set project and scenario names from user args if provided, otherwise parse from branch name
if [ -n "$USER_PROJECT_NAME" ]; then
  PROJECT_NAME="$USER_PROJECT_NAME"
else
  PROJECT_NAME=$(echo "$BRANCH_NAME" | awk -F'-' '{print $1}')
fi
if [ -n "$USER_SCENARIO_NAME" ]; then
  SCENARIO_NAME="$USER_SCENARIO_NAME"
else
  SCENARIO_NAME=$(echo "$BRANCH_NAME" | awk -F'-' '{OFS="-"; print $2,$3,$4,$5,$6}' | sed 's/-$//')
fi

# 2. Poll for LinearB AI review comment or review
if [ "$IS_PR_URL" = true ]; then
  print_status "Polling for LinearB AI review (comment or review) on PR #$PR_NUMBER (timeout: $((TIMEOUT/60)) min) ..."
else
  print_status "Polling for LinearB AI review (comment or review) for branch $BRANCH_NAME (PR #$PR_NUMBER, timeout: $((TIMEOUT/60)) min) ..."
fi
START_TIME=$(date +%s)
AI_REVIEWS_JSON=""
AI_REVIEWS_ARRAY="[]"
while true; do
  # First, check issue comments
  COMMENTS_JSON=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
    "$GITHUB_API/repos/$REPO_OWNER/$REPO_NAME/issues/$PR_NUMBER/comments")
  COMMENT_COUNT=$(echo "$COMMENTS_JSON" | jq 'length')
  print_status "[DEBUG] Issue comments JSON (count: $COMMENT_COUNT)"
  # Collect all comments by linear-b[bot]
  AI_COMMENTS=$(echo "$COMMENTS_JSON" | jq '[.[] | select(.user.login=="linear-b[bot]") | {type: "issue_comment", body: .body}]')
  if [ "$AI_COMMENTS" != "[]" ]; then
    AI_REVIEWS_ARRAY=$(jq -s 'add' <(echo "$AI_REVIEWS_ARRAY") <(echo "$AI_COMMENTS"))
  fi
  # If not found, check PR reviews
  REVIEWS_JSON=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
    "$GITHUB_API/repos/$REPO_OWNER/$REPO_NAME/pulls/$PR_NUMBER/reviews")
  REVIEW_COUNT=$(echo "$REVIEWS_JSON" | jq 'length')
  print_status "[DEBUG] PR reviews JSON (count: $REVIEW_COUNT)"
  # Collect all reviews by linear-b[bot]
  AI_PR_REVIEWS=$(echo "$REVIEWS_JSON" | jq '[.[] | select(.user.login=="linear-b[bot]") | {type: "pr_review", body: .body}]')
  if [ "$AI_PR_REVIEWS" != "[]" ]; then
    AI_REVIEWS_ARRAY=$(jq -s 'add' <(echo "$AI_REVIEWS_ARRAY") <(echo "$AI_PR_REVIEWS"))
  fi
  # Collect all reviews by gitstream-cm[bot] with LinearB marker
  AI_GS_REVIEWS=$(echo "$REVIEWS_JSON" | jq '[.[] | select(.user.login=="gitstream-cm[bot]" and (.body | test("Generated by LinearB AI"))) | {type: "pr_review", body: .body}]')
  if [ "$AI_GS_REVIEWS" != "[]" ]; then
    AI_REVIEWS_ARRAY=$(jq -s 'add' <(echo "$AI_REVIEWS_ARRAY") <(echo "$AI_GS_REVIEWS"))
  fi
  # If we have any AI reviews, break
  if [ "$(echo "$AI_REVIEWS_ARRAY" | jq 'length')" -gt 0 ]; then
    print_success "Found LinearB AI review(s)."
    break
  fi
  # Timeout check
  NOW=$(date +%s)
  ELAPSED=$((NOW - START_TIME))
  if [ $ELAPSED -ge $TIMEOUT ]; then
    if [ "$IS_PR_URL" = true ]; then
      print_error "Timed out waiting for LinearB AI review (comment or review) on PR #$PR_NUMBER ($INPUT)."
    else
      print_error "Timed out waiting for LinearB AI review (comment or review) for branch $BRANCH_NAME (PR #$PR_NUMBER)."
    fi
    break
  fi
  print_status "No AI review found yet. Waiting $POLL_INTERVAL seconds... ($(( (TIMEOUT-ELAPSED)/60 )) min left)"
  sleep $POLL_INTERVAL
done

# 3. Fetch all inline review comments (pull request review comments)
INLINE_COMMENTS_JSON=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
  "$GITHUB_API/repos/$REPO_OWNER/$REPO_NAME/pulls/$PR_NUMBER/comments")
INLINE_COMMENTS=$(echo "$INLINE_COMMENTS_JSON" | jq '[.[] | {user: .user.login, path: .path, position: .position, body: .body}]')

# 4. Scenario description lookup and expected review extraction
EXPECTED_REVIEW=""
SCORE="[N/A]"
PASS_FAIL="[N/A]"
if [ -n "$SCENARIO_NAME" ] && [ "$SCENARIO_NAME" != "unknown" ]; then
  SCENARIO_DESC="scenario-descriptions/$SCENARIO_NAME.txt"
  if [ -f "$SCENARIO_DESC" ]; then
    EXPECTED_REVIEW=$(awk '/^EXPECTED REVIEW/{flag=1; next} /^$/{flag=0} flag' "$SCENARIO_DESC")
    SCORE="[STUB]"
    PASS_FAIL="[STUB]"
  else
    EXPECTED_REVIEW="[Scenario description not found: $SCENARIO_DESC]"
  fi
else
  SCENARIO_DESC="[not_applicable]"
  EXPECTED_REVIEW="[Scenario comparison not available for this input. Run with a scenario branch or provide scenario name for comparison.]"
fi

# 5. Write results to file
TIMESTAMP=$(date -u +"%Y-%m-%dT%H-%M-%SZ")
# Sanitize branch and repo names for filenames
SAFE_REPO_NAME=$(echo "$REPO_NAME" | tr '/' '_')
SAFE_BASE_BRANCH=$(echo "$BASE_BRANCH" | tr '/' '_' | tr -c '[:alnum:]_-' '_')
SAFE_BRANCH_NAME=$(echo "$BRANCH_NAME" | tr '/' '_' | tr -c '[:alnum:]_-' '_')
RESULT_FILE="$RESULTS_DIR/${TIMESTAMP}__${SAFE_REPO_NAME}__${SAFE_BASE_BRANCH}__${SAFE_BRANCH_NAME}.json"
cat > "$RESULT_FILE" <<EOF
{
  "branch": "$BRANCH_NAME",
  "project": "$PROJECT_NAME",
  "scenario": "$SCENARIO_NAME",
  "pr_number": "$PR_NUMBER",
  "pr_url": "$PR_URL",
  "timestamp": "$TIMESTAMP",
  "ai_reviews": $AI_REVIEWS_ARRAY,
  "inline_comments": $INLINE_COMMENTS,
  "expected_review": $(jq -Rs . <<< "$EXPECTED_REVIEW"),
  "score": "$SCORE",
  "pass_fail": "$PASS_FAIL"
}
EOF
print_success "Evaluation complete. Results written to $RESULT_FILE" 